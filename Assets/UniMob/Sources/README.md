# UniMob [![Github license](https://img.shields.io/github/license/vanifatovvlad/UniMob.svg)](#) [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](#) [![Stars](https://img.shields.io/github/stars/vanifatovvlad/UniMob.svg?style=social)](https://github.com/vanifatovvlad/UniMob/stargazers) [![Watchers](https://img.shields.io/github/watchers/vanifatovvlad/UniMob.svg?style=social)](https://github.com/vanifatovvlad/UniMob/watchers)
_Простое и масштабируемое управление состоянием_
<br>

## Введение

UniMob - это простая и масштабируемая библиотека управления состояниями, в которой прозрачно применяется объектно-ориентированное реактивное программирование (OORP). Принцип проектирования UniMob очень прост:

> _Все, что может быть вычислено из состояния приложения, должно быть вычислено. Автоматически._

Это включает в себя пользовательский интерфейс, сериализацию данных, взаимодействие с сервером и т. д.

## Основные концепции

UniMob имеет несколько основных концепций.

### Наблюдаемое состояние

UniMob позволяет обернуть любые данные в реактивную обёртку.

```csharp
using UniMob;

public class Todo
{
    public int Id = 0;
    public MutableAtom<string> Title = Atom.Value("");
    public MutableAtom<bool> Finished = Atom.Value(false);
}
```

Использование `Atom` похоже на превращение свойства объекта в ячейку электронной таблицы.

### Вычисляемые значения

С UniMob вы можете создать значения, которые будут вычислены автоматически когда соответствующие данные изменяются.

```csharp
using UniMob;
using System.Linq;

public class TodoList
{
    public MutableAtom<Todo[]> Todos = Atom.Value(new Todo[0]);
    public Atom<int> UnfinishedTodoCount;

    public TodoList()
    {
        UnfinishedTodoCount = Atom.Computed(() => Todos.Value.Count(t => t.Finished.Value));
    }
}
```

UniMob обеспечит автоматическое обновление «UnfinishedTodoCount» при добавлении задачи или при изменении одного из свойств «Finished».
Подобные вычисления похожи на формулы в программах для работы с электронными таблицами, таких как MS Excel. Они обновляются автоматически и только при необходимости.

### Реакции

Реакции похожи на вычисляемые значение, но вместо создания нового значения реакция выполняет побочный эффект для таких вещей, как печать на консоль, выполнение сетевых запросов, обновление интерфейса и т. д.
Проще говоря, реакции соединяют [реактивное](https://en.wikipedia.org/wiki/Reactive_programming) и [императивное](https://en.wikipedia.org/wiki/Imperative_programming) программирование.

#### Пользовательские реакции

Пользовательские реакции могут быть созданы с помощью методов `AutoRun`, `Reaction` или `When` в зависимости от конкретной ситуации.

Например, следующая `Reaction` выводит в консоль сообщение каждый раз, когда изменяется значение «UnfinishedTodoCount»:

```csharp
Atom.Reaction(() => todos.UnfinishedTodoCount, (value, reaction) =>
{
    Debug.Log($"Tasks left: " + value);
});
```

### На какие изменения будет реагировать UniMob?

Почему новое сообщение печатается каждый раз, когда изменяется «UnfinishedTodoCount»? Ответ это правило:

> _UniMob реагирует на любое наблюдаемое свойство, которое читается во время выполнения отслеживаемой функции._

### Действия

Для UniMob нет разницы как будут обрабатываться пользовательские события.

-   Это может быть сделано с помощью System.Threading.Tasks.
-   Или путём обработки событий через UniRx.
-   Или обрабатывать события самым простым способом c помощью callbacks.

В конце концов все сводится к следующему: каким-то образом состояние приложения должно быть обновлено.

После обновления состояния `UniMob` позаботится об остальном эффективным способом и без сбоев. Итак, простых присвоений, подобных приведенным ниже, достаточно для автоматического обновления пользовательского интерфейса.

```csharp
store.Todos.Value = store.Todos.Value
    .Append(new Todo("Get Coffee"))
    .Append(new Todo("Get Coffee"))
    .ToArray();
store.Todos.Value[0].Finished.Value = true;
```

Техническая необходимость в вызове событий или чего-то другого отсутствует. Интерфейс, в конечном счёте, представляет собой не более чем причудливое представление вашего состояния, т. е. является реакцией, которой будет управлять UniMob.

## UniMob: Простой и масштарируемый

UniMob - это простая, масштабируемая и ненавязчивая библиотека управления состоянием.

### Использование прямых ссылок

С UniMob вам не нужно нормализовать ваши данные. Это делает библиотеку подходящей для очень сложных моделей предметной области.

### Ссылочная целостность гарантирована

Поскольку данные не нужно нормализовать, UniMob автоматически отслеживает отношения между состоянием и вычисляемыми значениями, вы получаете ссылочную целостность бесплатно.

Рендеринг чего-то, что доступно через три уровня косвенности? Нет проблем. UniMob будет отслеживать значение и выполнять повторный ре-рендер при изменении зависимых значений. В результате - ошибки устаревания устранены. Как программист, вы можете забыть, что изменение некоторых данных может повлиять на кажущийся не связанным элемент интерфейса, но UniMob не забудет.

### Простые действия легче поддерживать

Как показано выше, измененять состояние при использовании UniMob очень просто. Вы просто записываете свои намерения. UniMob позаботится обо всем остальном.

### Мелкозернистая наблюдаемость эффективна

UniMob строит граф всех зависимостей в вашем приложении, чтобы определить наименьшее количество повторных вычислений, необходимых для предотвращения устаревания. «Сделать наблюдаемым всё» может показаться дорогостоящим, но UniMob создает виртуальный граф зависимостей, чтобы минимизировать количество повторных вычислений, необходимых для синхронизации вычисляемых значений.

Фактически, использование этой библиотеки для отслеживания отношений часто намного эффективнее, чем проталкивание изменений с помощью рукописных событий или UniRx.

Простая причина в том, что UniMob установит гораздо более детализированные «слушатели» ваших данных, чем вы, как программист.

Во-вторых, UniMob видит причинно-следственную связь между производными, поэтому он может упорядочить их таким образом, чтобы ни одному производному не приходилось запускать дважды или вносить ошибку.

## UniMob или UniRx?

Общий вопрос - является ли UniMob заменой UniRx?

Во-первых, важно понимать, что stream библиотеки, хотя и схожи, решают проблему, отличную от UniMob. Это не конкурирующие, а скорее дополняющие понятия. Например, UniRx поможет вам реагировать на события, а UniMob поможет вам реагировать на значения (состояние). События и состояние фактически взаимозаменяемы.

Итак, когда вы должны предпочесть события состоянию или наоборот?

Предположим, у вас есть объект person с тремя атрибутами (наблюдаемые свойства в UniMob или потоки в UniRx):

```
public class Person
{
    public Person(string firstName, string lastName, string nickname)
    {
        FirstName = firstName;
        LastName = lastName;
        Nickname = nickname;
    }
}
```

Предположим, вы хотите реактивно получить «DisplayName» для человека. Вы хотите что-то вроде этого...

```
public string DisplayName => Nickname ?? (FirstName + " " + LastName);
```

В UniMob это будет выглядеть так:

```
DisplayName = Atom.Computed(() => Nickname ?? (FirstName + " " + LastName))
```

или даже так, если в кешировании «DisplayName» нет необходимости:
```
public string DisplayName => Nickname.Value ?? (FirstName.Value + " " + LastName.Value);
```

В UniRx вы бы сделали что-то вроде этого:

```
IReactiveProperty<string> DisplayName = person.Nickname
  .CombineLatest(FirstName, LastName, (nickname, firstname, lastname) => nickname ?? (firstname + " " + lastname))
  .DistinctUntilChanged()
  .ToReactiveProperty()
```

Эти две реактивные переменные имеют примерно одинаковое поведение, и примерно я имею в виду, что есть несколько различий, потому что UniMob применяет прозрачное реактивное программирование. В UniMob у вас нет специальных опраторов, и вещи объединяются с помощью обычных конструкций C#. В UniMob вы не определяете вручную зависимости для вычисляемого свойства, в UniRx вам нужно сделайте это с помощью CombineLatest или любым другим оператором.

UniMob автоматически прекратит отслеживание наблюдаемых свойств, которые не используются. Так, если у человека есть псевдоним, то имя и фамилия не имеют отношения к результату функции и, следовательно, они не будут отслеживаться. Это означает, что значение не будет перевычисляться, если FirstName или LastName меняется при использовании UniMob, но в случае UniRx значение будет перевычислено.

В UniMob значения лениво оцениваются на основе подписки. Они вычисляются только при наличии подписчиков.

Если псевдониму было присвоено новое, но точно такое же значение, в UniMob повторное вычисление также не будет выполнено (так как результат будет тем же), но в UniRx он будет выполнен (что можно исправить, введя DistinctUntilChanged() на всех потоках). Бывают ситуации, когда вы хотите, чтобы уведомление о повторных значениях реагировало, это выходит за рамки UniMob, и в таких случаях реактивные потоки могут выполнить эту задачу.



Итак, в заключение, когда нужно использовать библиотеки потоков поверх UniMob? Ответ: 
> Когда время играет важную роль. Приведенные выше примеры, где UniMob сияет - если вы можете получить значение из текущего состояния, прозрачное реактивное программирование намного проще и более согласованно благодаря прозрачному отслеживанию. Вам не нужно изучать операторы, и зависимости отслеживаются автоматически.


Но если время играет важную роль, например, при `event-Throttling`, `event-Accumulating` или при наличии сложных шаблонов соединения, таких как `zip`, это те случаи, когда предпочтительно работать с потоками.

UniMob достаточен, проще и эффективнее в 90% случаев; где вы хотите вычислить что-то из последнего состояния. Но для остальных 10% случаев реактивные библиотеки потоков действительно хороши.

И, что удивительно, бывают случаи, когда эти две концепции могут очень хорошо сочетаться друг с другом.

Например, если вы хотите ограничить пользовательский ввод перед обновлением состояния и остальной части приложения. Вы можете сделать это с помощью рабочего процесса, подобного этому:

```
События UI -> UniRx -> Обновление состояния -> UniMob -> Обновить UI
```

Люди используют такой рабочий процесс, и он очень мощный.

Подключить потоки UniRx к наблюдаемым значениям UniMob и наоборот на самом деле довольно просто!
