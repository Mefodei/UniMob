# UniMob [![Github license](https://img.shields.io/github/license/vanifatovvlad/UniMob.svg)](#) [![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](#) [![Stars](https://img.shields.io/github/stars/vanifatovvlad/UniMob.svg?style=social)](https://github.com/vanifatovvlad/UniMob/stargazers) [![Watchers](https://img.shields.io/github/watchers/vanifatovvlad/UniMob.svg?style=social)](https://github.com/vanifatovvlad/UniMob/watchers) [![NPM Publisher Support](https://img.shields.io/badge/maintained%20with-NPM%20Publisher%20Support-blue.svg)](https://github.com/vanifatovvlad/NpmPublisherSupport)
_Простое и масштабируемое управление состоянием_
<br>

## Введение

UniMob - это простая и масштабируемая библиотека управления состоянием, в которой прозрачно применяется объектно-ориентированное реактивное программирование (OORP). Принцип проектирования UniMob очень прост:

> _Все, что может быть вычислено из состояния приложения, должно быть вычислено. Автоматически._

Это включает в себя пользовательский интерфейс, сериализацию данных, взаимодействие с сервером и т. д.

<br>

![UniMob Flow](https://user-images.githubusercontent.com/26966368/61778573-ab182080-ae07-11e9-8f62-385099e7617c.png)

## Основные концепции

UniMob имеет несколько основных концепций.

### Наблюдаемое состояние

UniMob позволяет обернуть любые данные в реактивную обёртку.

```csharp
using UniMob;

public class Todo
{
    MutableAtom<string> _title = Atom.Value("");
    MutableAtom<bool> _finished = Atom.Value(false);

    public string Title
    {
        get => _title.Value;
        set => _title.Value = value;
    }

    public bool Finished
    {
        get => _finished.Value;
        set => _finished.Value = value;
    }
}
```

Использование `Atom` похоже на превращение свойства объекта в ячейку электронной таблицы.

### Вычисляемые значения

С UniMob вы можете создать значения, которые будут вычислены автоматически когда соответствующие данные изменяются.

```csharp
using UniMob;
using System.Linq;

public class TodoList
{
    MutableAtom<Todo[]> _todos = Atom.Value(new Todo[0]);
    Atom<int> _unfinishedTodoCount;

    public TodoList()
    {
        _unfinishedTodoCount = Atom.Computed(() => Todos.Count(t => t.Finished));
    }

    public Todo[] Todos
    {
        get => _todos.Value;
        set => _todos.Value = value;
    }

    public int UnfinishedTodoCount => _unfinishedTodoCount.Value;
}
```

UniMob обеспечит автоматическое обновление «UnfinishedTodoCount» при добавлении задачи или при изменении одного из свойств «Finished».
Подобные вычисления похожи на формулы в программах для работы с электронными таблицами, таких как MS Excel. Они обновляются автоматически и только при необходимости.

### Реакции

Реакции похожи на вычисляемые значение, но вместо создания нового значения реакция выполняет побочный эффект для таких вещей, как печать на консоль, выполнение сетевых запросов, обновление интерфейса и т. д.
Проще говоря, реакции соединяют [реактивное](https://en.wikipedia.org/wiki/Reactive_programming) и [императивное](https://en.wikipedia.org/wiki/Imperative_programming) программирование.

#### Пользовательские реакции

Пользовательские реакции могут быть созданы с помощью методов `AutoRun`, `Reaction` или `When` в зависимости от конкретной ситуации.

Например, следующая `AutoRun` выводит в консоль сообщение каждый раз, когда изменяется значение «UnfinishedTodoCount»:

```csharp
Atom.AutoRun(() =>
{
    Debug.Log($"Tasks left: " + UnfinishedTodoCount);
});
```

### На какие изменения будет реагировать UniMob?

Почему новое сообщение печатается каждый раз, когда изменяется «UnfinishedTodoCount»? Ответ это правило:

> _UniMob реагирует на любое наблюдаемое свойство, которое читается во время выполнения отслеживаемой функции._

### Действия

Для UniMob нет разницы как будут обрабатываться пользовательские события.

-   Это может быть сделано с помощью System.Threading.Tasks.
-   Или путём обработки событий через UniRx.
-   Или обрабатывать события самым простым способом c помощью callbacks.

В конце концов все сводится к следующему: каким-то образом состояние приложения должно быть обновлено.

После обновления состояния `UniMob` позаботится об остальном эффективным способом и без сбоев. Итак, простых присвоений, подобных приведенным ниже, достаточно для автоматического обновления пользовательского интерфейса.

```csharp
store.Todos = store.Todos
    .Append(new Todo("Get Coffee"))
    .Append(new Todo("Get Coffee"))
    .ToArray();
store.Todos[0].Finished = true;
```

Техническая необходимость в вызове событий или чего-то другого отсутствует. Интерфейс, в конечном счёте, представляет собой не более чем причудливое представление вашего состояния, т. е. является реакцией, которой будет управлять UniMob.

## UniMob: Простой и масштарируемый

UniMob - это простая, масштабируемая и ненавязчивая библиотека управления состоянием.

### Использование прямых ссылок

С UniMob вам не нужно нормализовать ваши данные. Это делает библиотеку подходящей для очень сложных моделей предметной области.

### Ссылочная целостность гарантирована

Поскольку данные не нужно нормализовать, UniMob автоматически отслеживает отношения между состоянием и вычисляемыми значениями, вы получаете ссылочную целостность бесплатно.

Рендеринг чего-то, что доступно через три уровня косвенности? Нет проблем. UniMob будет отслеживать значение и выполнять повторный ре-рендер при изменении зависимых значений. В результате - ошибки устаревания устранены. Как программист, вы можете забыть, что изменение некоторых данных может повлиять на кажущийся не связанным элемент интерфейса, но UniMob не забудет.

### Простые действия легче поддерживать

Как показано выше, измененять состояние при использовании UniMob очень просто. Вы просто записываете свои намерения. UniMob позаботится обо всем остальном.

### Мелкозернистая наблюдаемость эффективна

UniMob строит граф всех зависимостей в вашем приложении, чтобы определить наименьшее количество повторных вычислений, необходимых для предотвращения устаревания. «Сделать наблюдаемым всё» может показаться дорогостоящим, но UniMob создает виртуальный граф зависимостей, чтобы минимизировать количество повторных вычислений, необходимых для синхронизации вычисляемых значений.

Фактически, использование этой библиотеки для отслеживания отношений часто намного эффективнее, чем проталкивание изменений с помощью рукописных событий или UniRx.

Простая причина в том, что UniMob установит гораздо более детализированные «слушатели» ваших данных, чем вы, как программист.

Во-вторых, UniMob видит причинно-следственную связь между данными, поэтому он может упорядочить их таким образом, чтобы не приходилось вычислять ни одно свойство дважды без необходимости.

## UniMob или UniRx?

Общий вопрос - является ли UniMob заменой UniRx?

Во-первых, важно понимать, что stream библиотеки, хотя и схожи, решают проблему, отличную от UniMob. Это не конкурирующие, а скорее дополняющие понятия. Например, UniRx поможет вам реагировать на события, а UniMob поможет вам реагировать на значения (состояние). События и состояние фактически взаимозаменяемы.

Итак, когда вы должны предпочесть события состоянию или наоборот?

Предположим, у вас есть объект person с тремя атрибутами (наблюдаемые свойства в UniMob или потоки в UniRx):

```csharp
public class Person
{
    public Person(string firstName, string lastName, string nickname)
    {
        FirstName = firstName;
        LastName = lastName;
        Nickname = nickname;
    }
}
```

Предположим, вы хотите реактивно получить «DisplayName» для человека. Вы хотите что-то вроде этого...

```csharp
public string DisplayName => Nickname ?? (FirstName + " " + LastName);
```

В UniMob это будет выглядеть так:

```csharp
DisplayName = Atom.Computed(() => Nickname ?? (FirstName + " " + LastName))
```

или даже так, если в кешировании «DisplayName» нет необходимости:
```csharp
public string DisplayName => Nickname ?? (FirstName + " " + LastName);
```

В UniRx вы бы сделали что-то вроде этого:

```csharp
IReactiveProperty<string> DisplayName = person.Nickname
  .CombineLatest(FirstName, LastName, (nickname, firstname, lastname) => nickname ?? (firstname + " " + lastname))
  .DistinctUntilChanged()
  .ToReactiveProperty()
```

Эти две реактивные переменные имеют примерно одинаковое поведение, и примерно я имею в виду, что есть несколько различий, потому что UniMob применяет прозрачное реактивное программирование. В UniMob у вас нет специальных опраторов, и вещи объединяются с помощью обычных конструкций C#. В UniMob вы не определяете вручную зависимости для вычисляемого свойства, в UniRx вам нужно сделайте это с помощью CombineLatest или любым другим оператором.

UniMob автоматически прекратит отслеживание наблюдаемых свойств, которые не используются. Так, если у человека есть псевдоним, то имя и фамилия не не влияют на результат функции и, следовательно, они не будут отслеживаться. Это означает, что значение не будет перевычисляться, если FirstName или LastName меняется при использовании UniMob, но в случае UniRx значение будет перевычислено.

В UniMob значения лениво оцениваются на основе подписки. Они вычисляются только при наличии подписчиков.

Если псевдониму было присвоено новое, но точно такое же значение, в UniMob повторное вычисление также не будет выполнено (так как результат будет тем же), но в UniRx он будет выполнен (что можно исправить, введя DistinctUntilChanged() на всех потоках). Бывают ситуации, когда вы хотите, чтобы уведомление о повторных значениях реагировало, это выходит за рамки UniMob, и в таких случаях реактивные потоки могут выполнить эту задачу.



Итак, в заключение, когда нужно использовать библиотеки потоков поверх UniMob? Ответ: 
> Когда время играет важную роль. Приведенные выше примеры, где UniMob сияет - если вы можете получить значение из текущего состояния, прозрачное реактивное программирование намного проще и более согласованно благодаря прозрачному отслеживанию. Вам не нужно изучать операторы, и зависимости отслеживаются автоматически.


Но если время играет важную роль, например, при `event-Throttling`, `event-Accumulating` или при наличии сложных шаблонов соединения, таких как `zip`, это те случаи, когда предпочтительно работать с потоками.

UniMob достаточен, проще и эффективнее в 90% случаев; где вы хотите вычислить что-то из последнего состояния. Но для остальных 10% случаев реактивные библиотеки потоков действительно хороши.

И, что удивительно, бывают случаи, когда эти две концепции могут очень хорошо сочетаться друг с другом.

Например, если вы хотите ограничить пользовательский ввод перед обновлением состояния и остальной части приложения. Вы можете сделать это с помощью рабочего процесса, подобного этому:

```
События UI -> UniRx -> Обновление состояния -> UniMob -> Обновление UI
```

Люди используют такой рабочий процесс, и он очень мощный.

Подключить потоки UniRx к наблюдаемым значениям UniMob и наоборот на самом деле довольно просто!
